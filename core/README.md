# Spring

### Spring공부의 출발점 
- 좋은 **객체 지향 프로그래밍**에 대해 아는 것
- **역할**과 **구현**으로 구분하는 것 -> 유연,단순,변경 편리
- 역할(**인터페이스**), 구현(인터페이스를 **구현한 클래스**)로 나누면 다형성을 사용하여 쉽게 구현 프로그래밍을 바꿀 수 있다

--- 
### 좋은 객체 지향 설계의  5가지 원칙(SOLID)
1. **SRP** : 단일 책임 원칙
  - 한 클래스는 하나의 책임만을 가져야 한다
  - 변경이 있을 때, 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이라고 할 수 있다.
  - 변경이 있을 때, 하나의 지점만 고치면 SRP를 잘 따른다고 할 수 있다
  - 계층에 따라 코드를 나눠 놓아서 -> 유지 보수를 쉽게한다
  - 책임에 따른 범위를 적절하게 잘 나눠야 한다
2. **OCP**: 개방 -폐쇄 원칙
  - 소프트웨어 요소는 확장에 열려 있거나 변경에는 닫혀 있어야 한다
  - 다형성!!!
  - 인터페이스를 구현한 새로운 클래스를 만들고(확장에 열려 있고), 그거를 구현(변경에는 닫혀있다)
  - 역할과 구현의 분리를 생각해보기
  - 그런데 구현 인스턴스를 바꾸려면, 클라이언트의 코드를 변경해야 한다(적용할 때...)-> 객체를 생산하고, 이런 관계를 맺어주는 설정자가 필요-> 이것이 스프링(스프링 컨테이너)
3. **LSP** : 리스코프 치환 원칙
  - 인터페이스와 구현체가 있다
  - 구현체가 인터페이스의 규약을 지켜야한다
  - 컴파일 성공을 넘어서, 기능적으로 구현이 정확해야한다
4. **ISP** :인터페이스 분리 원칙
  - 인터페이스를 분리 -> 사용자 클라이언트도 분리할 수 있다.
  - 인터페이스가 명확해지고, 대체 가능성이 높아진다
5. **DIP** : 의존관계 역전 원칙
  - 클라이언트 코드가 구현 클래스를 바라보지 않고, 역할인 인터페이스를 바라봐야한다는 것이다
  - 역할과 구현을 철저하게 분리해서 언제든 유연하게 바뀔 수 있게 해야한다, 즉 역할에 의존해야지 구현에 의존하면 안된다
  - 그래야 유연하게 구현체를 변경이 가능
  - 만약 구현에 의존하면 변경이 아주 어려워진다

---
- 그런데 역할과 구현을 나누다 보면, 구현체인 클래스에 의존하게 된다 -> DIP,OCP 위반
- 먼저 DIP를 만족시키기기 위해서, 인터페이스에만 의존하면 -> NPE문제 발생
- 외부에서 구현체를 적용시켜주면 좋겠다라는 생각에서 -> AppConfig등장! : AppConfig에서 DI(의존관계 주입)을 한다 -> 서비스 부분과 설정부분을 나눠줘서 OCP까지 만족(관심사의 분리)
- 하지만 웹 어플리케이션이라면? 클라이언트마다 다른 객체가 생성되어 메모리 소모가 커진다... -> 싱글톤 패턴으로 코드를 수정한다
- 하지만 싱글톤 패턴으로 코드를 수정하면, 양도 많아지고 DIP문제가 다시 발생 -> 이런 문제를 해결하고 편리함을 주는 **Spring**으로 웹 어플리케이션을 개발한다!!!

#### 제어권 역전(IoC)
- 프로그램에 대한 제어 흐름의 권한을 AppConfig가 가진 것처럼, 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것

#### 의존관계 주입(DI)
- 실행시점(런타임)에서 실제 구현 객체를 생성하고, 클라이언트에게 전달하여 클라이언트와 서버의 실제 의존관계가 연결 되는 것
- 객체 인스턴스를 생성하고 그 참조값을 전달하여 연결하는 것
- 의존관계 주입을 사용하면, 정적인 클래스 의존관계를 변경하지 않고 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다

### 의존관계 주입에는 두가지 방법이 있다
1. 자바코드로 직접 스프링 빈을 등록하는 방법(AppConfig)
2. 컴포넌트 스캔과 자동의존관계 설정방

---
### 1. 자바코드로 직접 스프링 빈을 등록하는 방법

- **`ApplicationContext`** : 스프링 컨테이너 , 인터페이스
- **`AnnotationConfigApplicationContext`**는 **`ApplicationContext`**를 구현한 클래스이다. 이걸로 스프링 컨테이너를 만든다.
- 스프링 컨테이너틑 xml,등등으로 만들 수 있지만 자바 설정 클래스인 AppConfig를 가장 많이 사용한다.
- **스프링 컨테이너 생성 과정**
  - new AnnotationConfigApplicationContext()로 **스프링 컨테이너**를 생성한다.
  - 스프링 컨테이너를 생성할 때 구상정보를 파라미터로 넘기는데 이때 `AppConig.class`를 넣어준다 -> 그러면 AppConfig클래스가 **스프링 빈**으로 **자동 등록** 된다.
  - 이때 AppConfig 클래스에 **`@Bean`**이 붙은 메서드를 스프링 컨테이너 안의 스프링 빈 저장소에 저장하는데, **메서드이름을 빈이름으로** , **return 값으로 반환값의 객체의 참조값**을 넣어준다
  - 그 후에 AppConfig 클래스 코드에 반환값의 생성자의 파라미터에 의존관계를 주입할 메서드명을 넣어주어서 **DI**를 만족한다
      - 다형성의 원칙에서 보자면 메서드를 만들때 우리가 역활과 구현을 구분하듯이, 이름 옆에 역할(추상적인 것)을 적고, 반환 타입에 구현(구체적인 것)을 적어준다
      - ApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class); 이렇게
      - 이 코드를 보고 역할에 관련되어서 이러이러한 구현체를 반환하는구나~라고 알 수 있다
   
  - 스프링 빈 조회하는 방법: **`ac.getBean(빈이름,타입)`**, **`ac.getBean(타입)`**, 조회대상 스프링 빈 없으면 예외 발생
  - 동일한 타입이 둘 이상 오류 -> 1. 빈이름과 타입 모두 적어서 반환 받기, **`ac.getBeansOfType()`**을 써서 Map형식으로 해당 타입의 모든 빈을 조회하기
  - 싱글톤 패턴 -> **``@Configuration``**을 이용해 바이트 코드를 조작하는 CGLIB기술을 이용해 싱글톤을 보장한다
    - 싱글톤 패턴에서는 항상 **무상태(stateless)**여야 한다 -> 클라이언트에 의존적인 필드가 없어야 하고, 값을 변경할 수 잇는 필드가 있으면 안된다.필드 대신 자바에서 공유되지 않는 지역변수,파라미터,ThreadLocal을 이용
    - CGLIB 바이트코드 조작 라이브러리를 사용해 AppConfig를 상속받은 임의의 다른 클래스를 만들고 그 다른 클래스를 스프링 빈으로 등록한다.
    - 스프링 설정 정보에는 항상 **`@Configuration`** 을 붙이자 -> 싱글톤을 보장함



### 2. 컴포넌트 스캔과 자동의존관계 설정
- 지금까지 스프링 빈을 등록할 때는 자바 코드의 @Bean이나 XML의 등을 통해서 설정 정보에 직접 등 록할 스프링 빈을 나열했다.
- 이렇게 등록해야 할 스프링 빈이 수십, 수백개가 되면 일일이 등록하기도 귀찮고, 설정 정보도 커지고, 누락하는 문제도 발생한다
- 역시 개발자는 반복을 싫어한다.(무엇보다 귀찮다 ㅠㅠ) 그래서 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다.
- 또 의존관계도 자동으로 주입하는 **`@Autowired`** 라는 기능도 제공한다.
- 컴포넌트 스캔을 사용하려면 **`@ComponentScan`을**  **설정정보(AppConfig)에** 붙여주면 된다
- 자바코드로 직접 스프링 빈 등록과 다르게, `@Bean` 으로 등록한 클래스가 하나도 없다
- **`@ComponentScan`은** 스프링 컨테이너에 **`@Component`가** 붙은 클래스를 찾아서 자동으로 스프링 빈에 등록해준다.
- 이때 클래스명의 앞글자를 소문자로 사용해 Bean 이름을 등록한다
- 자바코드로 직접 스프링 빈을 설정할땐 의존관계 또한 명시하였는데, 컴포넌트 스캔에선 이런 설정이 없기 때문에 **`@AutoWired`**를 이용해서 의존관계 주입을 해준다
- ** 컴포넌트 스캔과 자동 의존관계 주입 과정**
  - **`@ComponentScan`**이있는 패키지 포함 하위 패키지에서 **`@Component`** 애노테이션이 붙은 **클래스를** 찾아서 **스프링 컨테이너**에 **등록**한다
  - 이때 클래스명의 앞글자를 소문자로 바꿔서 bean이름으로 등록한다
  - @Component가 붙은 클래스 안에 생성자에 @AutoWired를 찾는다 -> 스프링 Bean에 객체를 등록하기 위해서 생성자를 호출하는데, 이때 생성자에 @AutoWired를 붙여서 의존관계를 주입한다.
  - 생성자를 실행시 스프링 Bean에 등록된 스프링 빈의 자료형(같은 타입)을 기준으로, 스프링 컨테이너에서 찾은 스프링 빈을 Bean 객체에 넣어서 의존관계를 주입한다 (이때, 등록된 스프링 Bean이므로, 의존관계는 싱글톤을 만족한다)    


























