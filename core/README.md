# Spring

### Spring공부의 출발점 
- 좋은 **객체 지향 프로그래밍**에 대해 아는 것
- **역할**과 **구현**으로 구분하는 것 -> 유연,단순,변경 편리
- 역할(**인터페이스**), 구현(인터페이스를 **구현한 클래스**)로 나누면 다형성을 사용하여 쉽게 구현 프로그래밍을 바꿀 수 있다

--- 
### 좋은 객체 지향 설계의  5가지 원칙(SOLID)
1. **SRP** : 단일 책임 원칙
  - 한 클래스는 하나의 책임만을 가져야 한다
  - 변경이 있을 때, 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이라고 할 수 있다.
  - 변경이 있을 때, 하나의 지점만 고치면 SRP를 잘 따른다고 할 수 있다
  - 계층에 따라 코드를 나눠 놓아서 -> 유지 보수를 쉽게한다
  - 책임에 따른 범위를 적절하게 잘 나눠야 한다
2. **OCP**: 개방 -폐쇄 원칙
  - 소프트웨어 요소는 확장에 열려 있거나 변경에는 닫혀 있어야 한다
  - 다형성!!!
  - 인터페이스를 구현한 새로운 클래스를 만들고(확장에 열려 있고), 그거를 구현(변경에는 닫혀있다)
  - 역할과 구현의 분리를 생각해보기
  - 그런데 구현 인스턴스를 바꾸려면, 클라이언트의 코드를 변경해야 한다(적용할 때...)-> 객체를 생산하고, 이런 관계를 맺어주는 설정자가 필요-> 이것이 스프링(스프링 컨테이너)
3. **LSP** : 리스코프 치환 원칙
  - 인터페이스와 구현체가 있다
  - 구현체가 인터페이스의 규약을 지켜야한다
  - 컴파일 성공을 넘어서, 기능적으로 구현이 정확해야한다
4. **ISP** :인터페이스 분리 원칙
  - 인터페이스를 분리 -> 사용자 클라이언트도 분리할 수 있다.
  - 인터페이스가 명확해지고, 대체 가능성이 높아진다
5. **DIP** : 의존관계 역전 원칙
  - 클라이언트 코드가 구현 클래스를 바라보지 않고, 역할인 인터페이스를 바라봐야한다는 것이다
  - 역할과 구현을 철저하게 분리해서 언제든 유연하게 바뀔 수 있게 해야한다, 즉 역할에 의존해야지 구현에 의존하면 안된다
  - 그래야 유연하게 구현체를 변경이 가능
  - 만약 구현에 의존하면 변경이 아주 어려워진다

---
- 그런데 역할과 구현을 나누다 보면, 구현체인 클래스에 의존하게 된다 -> DIP,OCP 위반
- 먼저 DIP를 만족시키기기 위해서, 인터페이스에만 의존하면 -> NPE문제 발생
- 외부에서 구현체를 적용시켜주면 좋겠다라는 생각에서 -> AppConfig등장! : AppConfig에서 DI(의존관계 주입)을 한다 -> 서비스 부분과 설정부분을 나눠줘서 OCP까지 만족(관심사의 분리)
- 하지만 웹 어플리케이션이라면? 클라이언트마다 다른 객체가 생성되어 메모리 소모가 커진다... -> 싱글톤 패턴으로 코드를 수정한다
- 하지만 싱글톤 패턴으로 코드를 수정하면, 양도 많아지고 DIP문제가 다시 발생 -> 이런 문제를 해결하고 편리함을 주는 **Spring**으로 웹 어플리케이션을 개발한다!!!

#### 제어권 역전(IoC)
- 프로그램에 대한 제어 흐름의 권한을 AppConfig가 가진 것처럼, 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것

#### 의존관계 주입(DI)
- 실행시점(런타임)에서 실제 구현 객체를 생성하고, 클라이언트에게 전달하여 클라이언트와 서버의 실제 의존관계가 연결 되는 것
- 객체 인스턴스를 생성하고 그 참조값을 전달하여 연결하는 것
- 의존관계 주입을 사용하면, 정적인 클래스 의존관계를 변경하지 않고 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다

### 의존관계 주입에는 두가지 방법이 있다
1. 자바코드로 직접 스프링 빈을 등록하는 방법(AppConfig)
2. 컴포넌트 스캔과 자동의존관계 설정방

---
### 1. 자바코드로 직접 스프링 빈을 등록하는 방법

- **ApplicationContext** : 스프링 컨테이너 , 인터페이스
- **AnnotationConfigApplicationContext**는 ApplicationContext를 구현한 클래스이다. 이걸로 스프링 컨테이너를 만든다.
- 스프링 컨테이너틑 xml,등등으로 만들 수 있지만 자바 설정 클래스인 AppConfig를 가장 많이 사용한다.
- 스프링 컨테이너 생성 과정
  - new AnnotationConfigApplicationContext()로 **스프링 컨테이너**를 생성한다.
  - 스프링 컨테이너를 생성할 때 구상정보를 파라미터로 넘기는데 이때 AppConig.class를 넣어준다 -> 그러면 AppConfig클래스가 **스프링 빈**으로 **자동 등록** 된다.
  - 이때 AppConfig 클래스에 **@Bean**이 붙은 메서드를 스프링 컨테이너 안의 스프링 빈 저장소에 저장하는데, **메서드이름을 빈이름으로** , **return 값으로 반환값의 객체의 참조값**을 넣어준다
  - 그 후에 AppConfig 클래스 코드에 반환값의 생성자의 파라미터에 의존관계를 주입할 메서드명을 넣어주어서 **DI**를 만족한다
      - 다형성의 원칙에서 보자면 메서드를 만들때 우리가 역활과 구현을 구분하듯이, 이름 옆에 역할(추상적인 것)을 적고, 반환 타입에 구현(구체적인 것)을 적어준다
      - ApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class); 이렇게
      - 이 코드를 보고 역할에 관련되어서 이러이러한 구현체를 반환하는구나~라고 알 수 있다
