# Spring

### Spring공부의 출발점 
- 좋은 **객체 지향 프로그래밍**에 대해 아는 것
- **역할**과 **구현**으로 구분하는 것 -> 유연,단순,변경 편리
- 역할(**인터페이스**), 구현(인터페이스를 **구현한 클래스**)로 나누면 다형성을 사용하여 쉽게 구현 프로그래밍을 바꿀 수 있다

--- 
### 좋은 객체 지향 설계의  5가지 원칙(SOLID)
1. **SRP** : 단일 책임 원칙
  - 한 클래스는 하나의 책임만을 가져야 한다
  - 변경이 있을 때, 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이라고 할 수 있다.
  - 변경이 있을 때, 하나의 지점만 고치면 SRP를 잘 따른다고 할 수 있다
  - 계층에 따라 코드를 나눠 놓아서 -> 유지 보수를 쉽게한다
  - 책임에 따른 범위를 적절하게 잘 나눠야 한다
2. **OCP**: 개방 -폐쇄 원칙
  - 소프트웨어 요소는 확장에 열려 있거나 변경에는 닫혀 있어야 한다
  - 다형성!!!
  - 인터페이스를 구현한 새로운 클래스를 만들고(확장에 열려 있고), 그거를 구현(변경에는 닫혀있다)
  - 역할과 구현의 분리를 생각해보기
  - 그런데 구현 인스턴스를 바꾸려면, 클라이언트의 코드를 변경해야 한다(적용할 때...)-> 객체를 생산하고, 이런 관계를 맺어주는 설정자가 필요-> 이것이 스프링(스프링 컨테이너)
3. **LSP** : 리스코프 치환 원칙
  - 인터페이스와 구현체가 있다
  - 구현체가 인터페이스의 규약을 지켜야한다
  - 컴파일 성공을 넘어서, 기능적으로 구현이 정확해야한다
4. **ISP** :인터페이스 분리 원칙
  - 인터페이스를 분리 -> 사용자 클라이언트도 분리할 수 있다.
  - 인터페이스가 명확해지고, 대체 가능성이 높아진다
5. **DIP** : 의존관계 역전 원칙
  - 클라이언트 코드가 구현 클래스를 바라보지 않고, 역할인 인터페이스를 바라봐야한다는 것이다
  - 역할과 구현을 철저하게 분리해서 언제든 유연하게 바뀔 수 있게 해야한다, 즉 역할에 의존해야지 구현에 의존하면 안된다
  - 그래야 유연하게 구현체를 변경이 가능
  - 만약 구현에 의존하면 변경이 아주 어려워진다

---
- 그런데 역할과 구현을 나누다 보면, 구현체인 클래스에 의존하게 된다 -> DIP,OCP 위반
- 먼저 DIP를 만족시키기기 위해서, 인터페이스에만 의존하면 -> NPE문제 발생
- 외부에서 구현체를 적용시켜주면 좋겠다라는 생각에서 -> AppConfig등장! : AppConfig에서 DI(의존관계 주입)을 한다 -> 서비스 부분과 설정부분을 나눠줘서 OCP까지 만족(관심사의 분리)
- 하지만 웹 어플리케이션이라면? 클라이언트마다 다른 객체가 생성되어 메모리 소모가 커진다... -> 싱글톤 패턴으로 코드를 수정한다
- 하지만 싱글톤 패턴으로 코드를 수정하면, 양도 많아지고 DIP문제가 다시 발생 -> 이런 문제를 해결하고 편리함을 주는 **Spring**으로 웹 어플리케이션을 개발한다!!!

#### 제어권 역전(IoC)
- 프로그램에 대한 제어 흐름의 권한을 AppConfig가 가진 것처럼, 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것

#### 의존관계 주입(DI)
- 실행시점(런타임)에서 실제 구현 객체를 생성하고, 클라이언트에게 전달하여 클라이언트와 서버의 실제 의존관계가 연결 되는 것
- 객체 인스턴스를 생성하고 그 참조값을 전달하여 연결하는 것
- 의존관계 주입을 사용하면, 정적인 클래스 의존관계를 변경하지 않고 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다

### 의존관계 주입에는 두가지 방법이 있다
1. 자바코드로 직접 스프링 빈을 등록하는 방법(AppConfig)
2. 컴포넌트 스캔과 자동의존관계 설정방

---
### 1. 자바코드로 직접 스프링 빈을 등록하는 방법
- **`ApplicationContext`** : 스프링 컨테이너 , 인터페이스
- **`AnnotationConfigApplicationContext`**는 **`ApplicationContext`**를 구현한 클래스이다. 이걸로 스프링 컨테이너를 만든다.
- 스프링 컨테이너틑 xml,등등으로 만들 수 있지만 자바 설정 클래스인 AppConfig를 가장 많이 사용한다.
- 이때, **AppConfig 또한 스프링 빈**으로 스프링 컨테이너에 **저장된다.**

  
#### **스프링 컨테이너 생성 과정**
- new AnnotationConfigApplicationContext()로 **스프링 컨테이너**를 생성한다.
- 스프링 컨테이너를 생성할 때 구상정보를 파라미터로 넘기는데 이때 `AppConig.class`를 넣어준다 -> 그러면 AppConfig클래스가 **스프링 빈**으로 **자동 등록** 된다.
- 이때 AppConfig 클래스에 **`@Bean`**이 붙은 메서드를 스프링 컨테이너 안의 스프링 빈 저장소에 저장하는데, **메서드이름을 빈이름으로** , **return 값으로 반환값의 객체의 참조값**을 넣어준다
- 그 후에 AppConfig 클래스 코드에 반환값의 생성자의 파라미터에 의존관계를 주입할 메서드명을 넣어주어서 **DI**를 만족한다
  - 다형성의 원칙에서 보자면 메서드를 만들때 우리가 역활과 구현을 구분하듯이, 이름 옆에 역할(추상적인 것)을 적고, 반환 타입에 구현(구체적인 것)을 적어준다
  - ApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class); 이렇게
  - 이 코드를 보고 역할에 관련되어서 이러이러한 구현체를 반환하는구나~라고 알 수 있다
   
- 스프링 빈 조회하는 방법: **`ac.getBean(빈이름,타입)`**, **`ac.getBean(타입)`**, 조회대상 스프링 빈 없으면 예외 발생
- 동일한 타입이 둘 이상 오류 -> 1. 빈이름과 타입 모두 적어서 반환 받기, **`ac.getBeansOfType()`**을 써서 Map형식으로 해당 타입의 모든 빈을 조회하기
- 싱글톤 패턴 -> **``@Configuration``**을 이용해 바이트 코드를 조작하는 CGLIB기술을 이용해 싱글톤을 보장한다
  - 싱글톤 패턴에서는 항상 **무상태(stateless)**여야 한다 -> 클라이언트에 의존적인 필드가 없어야 하고, 값을 변경할 수 잇는 필드가 있으면 안된다.필드 대신 자바에서 공유되지 않는 지역변수,파라미터,ThreadLocal을 이용
  - CGLIB 바이트코드 조작 라이브러리를 사용해 AppConfig를 상속받은 임의의 다른 클래스를 만들고 그 다른 클래스를 스프링 빈으로 등록한다.
  - 스프링 설정 정보에는 항상 **`@Configuration`** 을 붙이자 -> 싱글톤을 보장함

---

### 2. 컴포넌트 스캔과 자동의존관계 설정


- 지금까지 스프링 빈을 등록할 때는 자바 코드의 @Bean이나 XML의 등을 통해서 설정 정보에 직접 등 록할 스프링 빈을 나열했다.
- 이렇게 등록해야 할 스프링 빈이 수십, 수백개가 되면 일일이 등록하기도 귀찮고, 설정 정보도 커지고, 누락하는 문제도 발생한다
- 역시 개발자는 반복을 싫어한다.(무엇보다 귀찮다 ㅠㅠ) 그래서 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다.
- 또 의존관계도 자동으로 주입하는 **`@Autowired`** 라는 기능도 제공한다.
- 컴포넌트 스캔을 사용하려면 **`@ComponentScan`을**  **설정정보(AppConfig)에** 붙여주면 된다
- 자바코드로 직접 스프링 빈 등록과 다르게, `@Bean` 으로 등록한 클래스가 하나도 없다
- **`@ComponentScan`은** 스프링 컨테이너에 **`@Component`가** 붙은 클래스를 찾아서 자동으로 스프링 빈에 등록해준다.
- 이때 클래스명의 앞글자를 소문자로 사용해 Bean 이름을 등록한다
- 자바코드로 직접 스프링 빈을 설정할땐 의존관계 또한 명시하였는데, 컴포넌트 스캔에선 이런 설정이 없기 때문에 **`@AutoWired`를** 이용해서 의존관계 주입을 해준다


#### 컴포넌트 스캔과 자동 의존관계 주입 과정
- **`@ComponentScan`**이있는 패키지 포함 하위 패키지에서 **`@Component`** 애노테이션이 붙은 **클래스를** 찾아서 **스프링 컨테이너**에 **등록**한다
- 이때 클래스명의 앞글자를 소문자로 바꿔서 **Bean이름**으로 등록한다
- **Bean객체**에는 메서드에 들어가는 파라미터의 객체의 참조값이 들어간다.
- 생성자 DI주입이므로, Spring Bean생성되는 동시에 **`@Component`가** 붙은 클래스 안에 생성자가 실행되고, **`@AutoWired`를**통해 자동 DI가 실행된다. 
- 생성자를 실행시 스프링 Bean에 등록된 **스프링 빈의 자료형(같은 타입)을** 기준으로, **의존관계를** 주입해준다
- 즉 생성자에 **`@AutoWired`를** 지정하면, 스프링 컨테이너가 **자동으로 해당 스프링 빈을 찾아서** **의존관계**를 **주입**한다.

---

### 중복 등록과 충돌

스프링 빈으로 등록하는 방법이 2개이므로, 충돌이 나면 어떻게 될까??
- 자동 빈 등록 vs 자동 빈 등록
  - 자동으로 등록되는 스프링 빈의 이름이 같은 때->ConflictingBeanDefinitionException()
  - Component("service"), Component("service")이런 상황...
  - 거의 없다..
- 수동 빈 등록 VS 자동 빈 등록
  - Overriding bean definition 뭔말이냐.. 수동 등록 빈이 우선권을 갖는다!!!-> **수동빈이 자동빈**을 **오버라이드** 해버린다
  - 그런데 여러 설정들이 꼬여서 이런 결과가 만들어진다...
  - 정말 잡기 어려운 버그가 만들어진다. **항상 잡기 어려운 버그는 애매한 버그다...**
  - 그래서 스프링 부트는 **수동빈과 자동빈**이 **충돌**하면 **자동으로 오류**가 나버린다
  - **스프링 부트**에서 실행하면 바로 오류가 난다!!!
  - The bean 'memoryMemberRepository', defined in class path resource [hello/core/AutoAppConfig.class], could not be registered. A bean with that name has already been defined in file                       - 
  - 스프링 부트가 이런 오버라이딩을 꺼버렸다

---

### 의존관계 자동 주입


1. 생성자 주입
  - 생성자 호출 시점에서 딱 **1번만 호출되는 것이 보장** (이렇게 불변하는 코드가 좋은 코드이다!)
  - 딱 생성 시점에 한번 참조값을 세팅하고, 그 후에는 세팅을 막을 수 없다
  - **불뱐, 필수** 의존관계에서 사용
  - **스프링 빈**에서 **생성자가 딱 1**개라면, **`@AutoWired`를** **생략**해도 **자동 주입**이 된다.
  - 그리고 필드값을 **private final로** **상수로** 선언할 수 있다 -> 이렇게 되면 생성자에 실수로 적지 않으면 **컴파일 오류**가 나서 오류를 방지할 수 있다!!!
2. 수정자 주입(setter)
  - **선택,변경** 가능성이 있는 의존관계
3. 필드 주입
4. 일반 메서드 주입

- 스프링에서 의존관계 자동 주입은 스프링 컨테이너가 관리하는 **스프링 빈**이어야 작동한다 ->@Component여야 한다는 소리


#### 생성자 주입을 선택하여라!!!

- 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없어야한다.
- 뭔말이냐면 애플리케이션 조립을, 공연에 비유해보자. 정해진 배역이 끝날때까지 변하지 않는 것처럼, 애플리케이션을 종료할 때까지 **의존관계를 변경할 일이 없다**
- 대부분의 의존관계는 애플리케이션 종료까지 변하면 안된다
- 그렇기에 생성자 주입이 최고의 선택이다!!!
- 그리고 프레임워크(Spring) 없이 **순수한 자바 코드로 test하는 코드가 정말 좋은 테스트**인데, 만약 생성자 주입으로 코드를 짰다면 **NullPointException이** 일어난다. 따라서 객체를 생성하고 setter까지 해줘야한다
- 또한 **final키워드**를 사용해서 실수를 방지할 수도 있다


**** 롬복
- getter,setter,toString등을 애노테이션으로 자동으로 만들어준다
- @RequiredArgsConstructor : final이 붙은 필드값의 생성자를 만들어 준다
- 즉 final로 필드를 만들고 생성자 주입을 해주면 굳이 생성자를 호출하지 않고 @RequiredArgsConstructor 에노테이션으로 바로 생성자를 대체할 수 있다
- ctrl +f12 :  이 클래스의 모든 메서드들을 보여준다

---
### 조회한 빈이 2개 이상일때에는??
- 우리는 DIP를 만족시키기 위해서 인터페이스를 자료형으로 Bean을 많이 등록한다
- @AutoWired가 타입으로 조회하기때문에, 만약 DiscountPolicy 의 하위 타입인 FixDiscountPolicy , RateDiscountPolicy 둘다 스프링 빈으로 선언했다고 가정해보자.. -> 오류가 나겠지?(둘중 어떤 것을 DI할지 모르기 때문에...)
- DiscountPolic의 생성자에서 스프링 빈을 주입할려고 봤더니 같은 타입이 FixDiscountPolicy, RateDiscountPolicy 두개가 있어서 NoUniqueBeanDefinitionException 오류가 난다
- 하위 타입으로 타입을 지정할 수 있지만, 하위 타입을 지정하는 것은 역할을 의존하는게 아닌, 구현체를 의존하는 코드 이므로 DIP를 위배하고, 결국 유연성이 떨어진다

해결방법에는 3가지가 있다


1. @Autowired필드명
2. @Qualifier
3. @Primary

- @AutoWired의 필드명을 바꾸는 것은 스프링 부트 3.2버젼이후부터 지원하지 않는다
- @Qualifier은 추가 구분자를 붙여주는 방식이다. 빈 이름을 변경하는 것은 아님
    - 빈 등록시 @Qualifier("")을 붙여주고
    - 생성자에서 @Qualifier을 2개 이상 스프링 빈이 등록된 파라미터 앞에 적어준다
    - 만약 그런 Qualifier가 없다면, 같은 이름의 스프링 빈을 찾는다
    - 하지만 경험상 @Qualifier는 @Qualifier만 찾는게 좋다!
 - Primary : 컴포넌트에(등록하는 스프링 빈에) @Primary를 붙인다
   - 그러면 우선순위를 가지고 의존관계가 주입된다
- Qualifier : 자세,상세하게 작동
- Primary : 기본값처럼 작동
- Spring은 자세한게 우선순위를 가지므로 같이 사용시 @Qualifier가 우선순위를 갖는다
- 만약 db를 2개 쓴느데 하나를 메인 db고 나머지하나는 아주 가끔 쓰는 서브 db라고 하자 . 이럴때 메인 db커넥션을 가져오는 코드에 @Primary로 의존관계를 간단히 주입하고, 보조 db에는 Qualifier을 사용해 직접 이름으로 가져온다


### 조회한 빈이 모두 필요할 때, List, Map
- 할인 관련에 대해 클라이언트가 선택할 수 있게 - >이럴때 스프링빈을 List,Map으로 받아올 수 있다.
- 리스트, 맵이 있는 클래스를 Config로 Spring컨테이너 박스에 구상정보를 넘겨준다
- 전략패턴을 간단하게 구사할 수 있다!
- 스프링 컨테이너는 생성자에 클래스 정보를 받는다. 이때 클래스 정보를 넘기면 해당 클래스가 스프링 빈으로 자동 등록이 된다.

---
## 그렇다면 지금까지 의존관계를 자바코드로 수동으로 넣는 방법과, 컴포넌트 스캔으로 자동으로 넣는 방법을 배웠다. 언제 어떤 방법을 사용해야 될까???

- 애플리케이션은 크게 **업무 로직**과 **기술 지원 로직**으로 나눌 수 있다
- **업무 로직 빈** : 웹을 지원하는 **컨트롤러**, 핵심 비지니스 로직이 있는 **서비스**, 데이터 계층의 로직을 처리하는 **리포지토리**등등... **보통 비지니스 요구사항을 개발할 때 추가되거나 변경된다**
- **기술 지원 빈** : 기술적인 문제, 공통 관심사(AOP) 처리할때, db연결, 공통 로그 처리 ...
- **업무 로직 빈에서는 자동 컴포넌트 스캔을 이용하고, 기술 지원 빈에서는 수동 방식을 이용해라!**
- 기술 지원 빈은 애플리케이션에 광범위하게 영향을 미치므로 어디서 오류가나는지 모르고, 수동빈으로 등록해 설정정보에서 바로 보이게 해서 **유지보수**를 신경쓰자
- 수동으로 하든, 컴포넌트 스캩을 통해 의존관계를 주입하든... 가장 중요한 것은 딱 보고 **쉽게 이해**가 되야 하는 것이다.


















